<?xml version='1.0' encoding='utf-8'?>
<harness_options>
  <length>
    <string_value lines="1">long</string_value>
  </length>
  <owner>
    <string_value lines="1">cwilson</string_value>
  </owner>
  <description>
    <string_value lines="1">King benchmark.</string_value>
  </description>
  <simulations>
    <simulation name="TimeDependent">
      <input_file>
        <string_value type="filename" lines="1">rbconvection_checkpoint_0.tfml</string_value>
      </input_file>
      <run_when name="input_changed_or_output_missing"/>
      <number_processes>
        <integer_value rank="0">1</integer_value>
      </number_processes>
      <parameter_sweep>
        <parameter name="ncells">
          <values>
            <string_value lines="1">16</string_value>
          </values>
        </parameter>
        <parameter name="Ra_b">
          <values>
            <string_value lines="1">(9.e5 7.e5)</string_value>
          </values>
          <update>
            <string_value type="code" language="python3" lines="20">import libspud

libspud.set_option("/system::Stokes/coefficient::RayleighNumber/type/rank/value/constant", float(Ra_b[0]))</string_value>
            <single_build/>
          </update>
        </parameter>
        <parameter name="Di_b">
          <values>
            <string_value lines="1">(0.25 0.25)</string_value>
          </values>
          <update>
            <string_value type="code" language="python3" lines="20">import libspud

libspud.set_option("/system::Stokes/coefficient::DissipationNumber/type/rank/value/constant", float(Di_b[0]))</string_value>
            <single_build/>
          </update>
        </parameter>
      </parameter_sweep>
      <dependencies>
        <simulation name="SteadyState">
          <input_file>
            <string_value type="filename" lines="1">king.tfml</string_value>
          </input_file>
          <run_when name="input_changed_or_output_missing"/>
          <number_processes>
            <integer_value rank="0">1</integer_value>
          </number_processes>
          <parameter_sweep>
            <parameter name="ncells"/>
            <parameter name="Ra_b">
              <update>
                <string_value type="code" language="python3" lines="20">import libspud

libspud.set_option("/system::Stokes/coefficient::RayleighNumber/type/rank/value/constant", float(Ra_b[1]))</string_value>
                <single_build/>
              </update>
            </parameter>
            <parameter name="Di_b">
              <update>
                <string_value type="code" language="python3" lines="20">import libspud

libspud.set_option("/system::Stokes/coefficient::DissipationNumber/type/rank/value/constant", float(Di_b[1]))</string_value>
                <single_build/>
              </update>
            </parameter>
          </parameter_sweep>
          <required_output>
            <filenames name="ics">
              <python>
                <string_value type="code" language="python3" lines="20">systems = ["Stokes", "CourantNumber", "ViscousDissipation", "WorkDone"]
ics  = ["rbconvection_{}_0.xdmf".format(system,) for system in systems]
ics += ["rbconvection_{}_0.h5".format(system,) for system in systems]</string_value>
              </python>
            </filenames>
            <filenames name="tfml">
              <string>
                <string_value type="filename" lines="1">rbconvection_checkpoint_0.tfml</string_value>
              </string>
            </filenames>
          </required_output>
          <dependencies>
            <run name="Mesh">
              <input_file>
                <string_value type="filename" lines="1">../../src/transfinite_square.geo</string_value>
              </input_file>
              <run_when name="input_changed_or_output_missing"/>
              <parameter_sweep>
                <parameter name="ncells">
                  <update>
                    <string_value type="code" language="python3" lines="20">from string import Template as template
input_file = template(input_file).safe_substitute({'ncells':ncells, 'factor':'0.01'})</string_value>
                  </update>
                </parameter>
              </parameter_sweep>
              <required_output>
                <filenames name="meshfiles">
                  <python>
                    <string_value type="code" language="python3" lines="20">meshfiles = ["transfinite_square"+ext for ext in [".xdmf", ".h5", "_facet_ids.xdmf", "_facet_ids.h5", "_cell_ids.xdmf", "_cell_ids.h5"]]</string_value>
                  </python>
                </filenames>
              </required_output>
              <commands>
                <command name="GMsh">
                  <string_value lines="1">gmsh -2 transfinite_square.geo</string_value>
                </command>
                <command name="Convert">
                  <string_value lines="1">tfgmsh2xdmf transfinite_square.msh</string_value>
                </command>
              </commands>
            </run>
          </dependencies>
          <variables>
            <variable name="variables_ss">
              <string_value type="code" language="python3" lines="20">from buckettools.statfile import parser
import os
from buckettools.threadlibspud import *
import numpy as np
from collections import OrderedDict

filename = os.path.split(input_filename)[-1]
threadlibspud.load_options(filename)
basename = libspud.get_option("/io/output_base_name")
finishtime = libspud.get_option("/timestepping/finish_time")
steadytol = libspud.get_option("/timestepping/steady_state/tolerance")
threadlibspud.clear_options()

det = parser(basename+".det")
stat = parser(basename+".stat")
steady = parser(basename+".steady")

change = max(steady["Stokes"]["Velocity"]["change(linf)"][:,-1].max(), 
             steady["Stokes"]["Pressure"]["change(linf)"][-1],
             steady["Stokes"]["Temperature"]["change(linf)"][-1])
time = steady["ElapsedTime"]["value"][-1]

variables_ss = OrderedDict()
variables_ss["Ra"]      = Ra
variables_ss["Di"]      = Di
variables_ss["Nu_top"]  = -stat["Stokes"]["TemperatureFullTopSurfaceIntegral"]["functional_value"][-1]
variables_ss["Nu_bot"]  = -stat["Stokes"]["TemperatureFullBottomSurfaceIntegral"]["functional_value"][-1]
variables_ss["Vrms"]    = np.sqrt(stat["Stokes"]["VelocityL2NormSquared"]["functional_value"][-1])*float(Ra)
variables_ss["Vtopinf"] = np.abs(det["Stokes"]["Velocity_0"]["Array"][:,-1]).max()*float(Ra)
variables_ss["Vtopint"] = stat["Stokes"]["VelocityTopSurfaceIntegral"]["functional_value"][-1]*float(Ra)
variables_ss["Tint"]    = stat["Stokes"]["TemperatureFullIntegral"]["functional_value"][-1]
variables_ss["Phiint"]  = stat["ViscousDissipation"]["ViscousDissipationIntegral"]["functional_value"][-1]*float(Ra)*float(Di)
variables_ss["Wint"]    = stat["WorkDone"]["WorkDoneIntegral"]["functional_value"][-1]*float(Ra)
variables_ss["dPhiW"]   = abs(variables["Phiint"]-variables["Wint"])/variables["Wint"]*100
variables_ss["dNu"]     = abs(variables["Nu_top"]-variables["Nu_bot"])/variables["Nu_bot"]*100
variables_ss["Vtopmax"] = det["Stokes"]["Velocity_0"]["Array"][:,-1].max()*float(Ra)
variables_ss["Vtopmin"] = det["Stokes"]["Velocity_0"]["Array"][:,-1].min()*float(Ra)
variables_ss["steady"]  = "T" if change &lt; steadytol and time &lt; finishtime else "F"
variables_ss["Vtoprev"] = "T" if variables["Vtopmax"]*variables["Vtopmin"] &lt; -1.e-6 else "F"</string_value>
            </variable>
            <variable name="errfile_ss">
              <string_value type="code" language="python3" lines="20">import os
err = open("terraferma.err-0", 'r')

print(err.read())
err.seek(0)

linecount = -1
errfile_ss = []
for line in err.readlines():
  if not line.startswith("WARNING:") and not line.startswith(os.linesep):
    if line.startswith("*** WARNING:"):
      linecount = 0
    elif linecount &gt;= 0:
      if line.startswith("-----------"):
        linecount += 1
      if linecount == 2:
        linecount = -1
    else:
      errfile_ss.append(line)

err.close()</string_value>
            </variable>
          </variables>
        </simulation>
      </dependencies>
      <variables>
        <variable name="variables">
          <string_value type="code" language="python3" lines="20">from buckettools.statfile import parser
import os
from buckettools.threadlibspud import *
import numpy as np
from collections import OrderedDict

filename = os.path.split(input_filename)[-1]
threadlibspud.load_options(filename)
basename = libspud.get_option("/io/output_base_name")
finishtime = libspud.get_option("/timestepping/finish_time")
steadytol = libspud.get_option("/timestepping/steady_state/tolerance")
threadlibspud.clear_options()

det = parser(basename+".det")
stat = parser(basename+".stat")
steady = parser(basename+".steady")

change = max(steady["Stokes"]["Velocity"]["change(linf)"][:,-1].max(), 
             steady["Stokes"]["Pressure"]["change(linf)"][-1],
             steady["Stokes"]["Temperature"]["change(linf)"][-1])
time = steady["ElapsedTime"]["value"][-1]

variables = OrderedDict()
variables["Ra"]      = Ra
variables["Di"]      = Di
variables["Nu_top"]  = -stat["Stokes"]["TemperatureFullTopSurfaceIntegral"]["functional_value"][-1]
variables["Nu_bot"]  = -stat["Stokes"]["TemperatureFullBottomSurfaceIntegral"]["functional_value"][-1]
variables["Vrms"]    = np.sqrt(stat["Stokes"]["VelocityL2NormSquared"]["functional_value"][-1])*float(Ra)
variables["Vtopinf"] = np.abs(det["Stokes"]["Velocity_0"]["Array"][:,-1]).max()*float(Ra)
variables["Vtopint"] = stat["Stokes"]["VelocityTopSurfaceIntegral"]["functional_value"][-1]*float(Ra)
variables["Tint"]    = stat["Stokes"]["TemperatureFullIntegral"]["functional_value"][-1]
variables["Phiint"]  = stat["ViscousDissipation"]["ViscousDissipationIntegral"]["functional_value"][-1]*float(Ra)*float(Di)
variables["Wint"]    = stat["WorkDone"]["WorkDoneIntegral"]["functional_value"][-1]*float(Ra)
variables["dPhiW"]   = abs(variables["Phiint"]-variables["Wint"])/variables["Wint"]*100
variables["dNu"]     = abs(variables["Nu_top"]-variables["Nu_bot"])/variables["Nu_bot"]*100
variables["Vtopmax"] = det["Stokes"]["Velocity_0"]["Array"][:,-1].max()*float(Ra)
variables["Vtopmin"] = det["Stokes"]["Velocity_0"]["Array"][:,-1].min()*float(Ra)
variables["steady"]  = "T" if change &lt; steadytol and time &lt; finishtime else "F"
variables["Vtoprev"] = "T" if variables["Vtopmax"]*variables["Vtopmin"] &lt; -1.e-6 else "F"</string_value>
        </variable>
        <variable name="errfile">
          <string_value type="code" language="python3" lines="20">import os
err = open("terraferma.err-0", 'r')

print(err.read())
err.seek(0)

linecount = -1
errfile = []
for line in err.readlines():
  if not line.startswith("WARNING:") and not line.startswith(os.linesep):
    if line.startswith("*** WARNING:"):
      linecount = 0
    elif linecount &gt;= 0:
      if line.startswith("-----------"):
        linecount += 1
      if linecount == 2:
        linecount = -1
    else:
      errfile.append(line)

err.close()</string_value>
        </variable>
      </variables>
    </simulation>
  </simulations>
  <tests>
    <test name="errors_ss">
      <string_value type="code" language="python3" lines="20">import sys
import itertools
noerrors = True

params = list(errfile_ss.parameters.keys())

for values in itertools.product(*errfile_ss.parameters.values()):
  label = ", ".join(["{} = {}".format(params[i], v) for i,v in enumerate(values) if len(errfile_ss.parameters[params[i]])&gt;1])
  key = {params[i]:v for i,v in enumerate(values)}
  if len(errfile_ss[key]) &gt; 0:
    print("ERROR: unexpected output in terraferma.err-0 for ({})!".format(label))
    print(errfile_ss[key])
    for line in errfile_ss[key]:
      print(line)
      sys.stdout.write(line)
    noerrors = False

assert(noerrors)</string_value>
    </test>
    <test name="print_ss">
      <string_value type="code" language="python3" lines="20">import itertools

params = list(variables_ss.parameters.keys())

variable = variables_ss[0]
for i in range(len(params)-1):
  variable = variable[0]
sstring = "{}\t"*len(variable.keys())
print(sstring.format(*[k for k in variable.keys()]))

paramvals = sorted(list(itertools.product(*variables_ss.parameters.values())), key=lambda x: [float(xi) for xi in x[::-1]])
for values in paramvals:
  label = "\t".join(["{}".format(v) for i,v in enumerate(values) if len(variables_ss.parameters[params[i]])&gt;1])
  key = {params[i]:v for i,v in enumerate(values)}
  variable = variables_ss[key]
  vstring = "{}\t"*2+"{:.4f}\t"*(len(variable.keys())-4)+"{}\t"*2
  print(vstring.format(*[v for v in variable.values()]))</string_value>
    </test>
    <test name="errors">
      <string_value type="code" language="python3" lines="20">import sys
import itertools
noerrors = True

params = list(errfile.parameters.keys())

for values in itertools.product(*errfile.parameters.values()):
  label = ", ".join(["{} = {}".format(params[i], v) for i,v in enumerate(values) if len(errfile.parameters[params[i]])&gt;1])
  key = {params[i]:v for i,v in enumerate(values)}
  if len(errfile[key]) &gt; 0:
    print("ERROR: unexpected output in terraferma.err-0 for ({})!".format(label))
    print(errfile[key])
    for line in errfile[key]:
      print(line)
      sys.stdout.write(line)
    noerrors = False

assert(noerrors)</string_value>
    </test>
    <test name="print">
      <string_value type="code" language="python3" lines="20">import itertools

params = list(variables.parameters.keys())

variable = variables[0]
for i in range(len(params)-1):
  variable = variable[0]
sstring = "{}\t"*len(variable.keys())
print(sstring.format(*[k for k in variable.keys()]))

paramvals = sorted(list(itertools.product(*variables.parameters.values())), key=lambda x: [float(xi) for xi in x[::-1]])
for values in paramvals:
  label = "\t".join(["{}".format(v) for i,v in enumerate(values) if len(variables.parameters[params[i]])&gt;1])
  key = {params[i]:v for i,v in enumerate(values)}
  variable = variables[key]
  vstring = "{}\t"*2+"{:.4f}\t"*(len(variable.keys())-4)+"{}\t"*2
  print(vstring.format(*[v for v in variable.values()]))</string_value>
    </test>
  </tests>
</harness_options>
